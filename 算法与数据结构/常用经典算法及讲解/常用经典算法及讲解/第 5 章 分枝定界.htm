<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=GB2312">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./No55.files/filelist.xml">
<title> 分枝定界</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>lixuewu</o:Author>
  <o:LastAuthor>a</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>1996-12-31T16:41:00Z</o:Created>
  <o:LastSaved>1996-12-31T16:41:00Z</o:LastSaved>
  <o:Pages>16</o:Pages>
  <o:Words>3695</o:Words>
  <o:Characters>21065</o:Characters>
  <o:Company>dksl</o:Company>
  <o:Lines>175</o:Lines>
  <o:Paragraphs>42</o:Paragraphs>
  <o:CharactersWithSpaces>25869</o:CharactersWithSpaces>
  <o:Version>9.2812</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:PunctuationKerning/>
  <w:DrawingGridHorizontalSpacing>5.25 磅</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>7.8 磅</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:DisplayVerticalDrawingGridEvery>2</w:DisplayVerticalDrawingGridEvery>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:AdjustLineHeightInTable/>
   <w:UseFELayout/>
  </w:Compatibility>
 </w:WordDocument>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-alt:SimSun;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:3 135135232 16 0 262145 0;}
@font-face
	{font-family:仿宋_GB2312;
	panose-1:2 1 6 9 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:"\@仿宋_GB2312";
	panose-1:2 1 6 9 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:1 135135232 16 0 262144 0;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;
	mso-font-charset:134;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:1 135135232 16 0 262144 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	mso-pagination:none;
	font-size:10.5pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:none;
	tab-stops:center 207.65pt right 415.3pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:宋体;
	mso-font-kerning:1.0pt;}
 /* Page Definitions */
@page
	{mso-page-border-surround-header:no;
	mso-page-border-surround-footer:no;
	mso-gutter-position:top;}
@page Section1
	{size:515.95pt 728.6pt;
	margin:72.0pt 2.0cm 65.2pt 2.0cm;
	mso-header-margin:36.0pt;
	mso-footer-margin:36.0pt;
	mso-even-footer:url("./No55.files/header.htm") ef1;
	mso-footer:url("./No55.files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=ZH-CN style='tab-interval:21.0pt;text-justify-trim:punctuation' bgcolor="#e8ffe8">
<div class=Section1>

<p class=MsoNormal align=left style='text-align:left;text-indent:96.0pt;
mso-char-indent-count:6.0;mso-char-indent-size:16.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:16.0pt;font-family:仿宋_GB2312;
color:blue;mso-font-kerning:0pt'>第<span lang=EN-US> 5 章 分枝定界<o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>任何美好的事情都有结束的时候。现在我们学习的是本书的最后一章。幸运的是，本章用到的大部分概念在前面各章中已作了介绍。类似于回溯法，分枝定界法在搜索解空间时，也经常使用树形结构来组织解空间（常用的树结构是第</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>章所介绍的子集树和排列树）。然而与回溯法不同的是，回溯算法使用深度优先方法搜索树结构，而分枝定界一般用宽度优先或最小耗费方法来搜索这些树。本章与第</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>章所考察的应用完全相同，因此，可以很容易比较回溯法与分枝定界法的异同。相对而言，分枝定界算法的解空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:12.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:12.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.1 </span><span
style='font-size:12.0pt;font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>算法思想<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:12.0pt;font-family:
仿宋_GB2312;color:blue;mso-font-kerning:0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>分枝定界（</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>branch and bound</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）是另一种系统地搜索解空间的方法，它与回溯法的主要区别在于对</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的扩充方式。每个活节点有且仅有一次机会变成</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。当一个节点变为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点时，则生成从该节点移动一步即可到达的所有新节点。在生成的节点中，抛弃那些不可能导出（最优）可行解的节点，其余节点加入活节点表，然后从表中选择一个节点作为下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。从活节点表中取出所选择的节点并进行扩充，直到找到解或活动表为空，扩充过程才结束。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>有两种常用的方法可用来选择下一个</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点（虽然也可能存在其他的方法）：<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>先进先出（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>） 即从活节点表中取出节点的顺序与加入节点的顺序相同，因此活节点表的性质与队列相同。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>最小耗费或最大收益法在这种模式中，每个节点都有一个对应的耗费或收益。如果查找一个具有最小耗费的解，则活节点表可用最小堆来建立，下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点就是具有最小耗费的活节点；如果希望搜索一个具有最大收益的解，则可用最大堆来构造活节点表，下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是具有最大收益的活节点。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>例<span lang=EN-US>5</span></span><span
lang=EN-US style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>-1 [</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>迷宫老鼠</span><span
lang=EN-US style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>] </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>考察图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>16-3a </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>给出的迷宫老鼠例子和图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的解空间结构。使用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界，初始时取（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）作为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点且活动队列为空。迷宫的位置（
</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 , 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被置为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，以免再次返回到这个位置。（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被扩充，它的相邻节点（ </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）和（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）加入到队列中（即活节点表）。为避免再次回到这两个位置，将位置（
</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）和（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）置为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。此时迷宫如图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 1 a</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所示，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被删除。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>节点（</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）从队列中移出并被扩充。检查它的三个相邻节点（见图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的解空间），只有（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）是可行的移动（剩余的两个节点是障碍节点），将其加入队列，并把相应的迷宫位置置为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，所得到的迷宫状态如图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>17-1b </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所示。节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被删除，而下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）将会被取出，当此节点被展开时，节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被加入队列中，节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被置为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被删除，所得到的迷宫如图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>17-1c </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所示。此时队列中包含（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）和（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）两个节点。随后节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）变成下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，由于此节点不能到达任何新的节点，所以此节点即被删除，节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）成为新的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，将队列清空。节点（ </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）展开，（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被加入队列中，而（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）被删除。（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）变为新的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，展开此节点后，到达节点（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>），即迷宫的出口。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>使用</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I
F O</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>搜索，总能找出从迷宫入口到出口的最短路径。需要注意的是：利用回溯法找到的路径却不一定是最短路径。有趣的是，程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>6 - 11</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>已经给出了利用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界搜索从迷宫的（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）位置到（</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span></i><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span></i><span style='font-size:10.0pt;
font-family:仿宋_GB2312;mso-ascii-font-family:"Times New Roman";color:black;
mso-font-kerning:0pt'>）</span><span style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'> </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>位置的最短路径的代码。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>例<span lang=EN-US>5</span></span><span
lang=EN-US style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>-2 [0/1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>背包问题</span><span lang=EN-US style='font-size:10.0pt;font-family:Arial;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>] </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>下面比较分别利用</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>分枝定界和最大收益分枝定界方法来解决如下背包问题：</span><i><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>n</span></i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>=3, <i>w</i>=[20,15,15], <i>p</i>=[40,25,25],
<i>c</i>= 3 0</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I
F O</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>分枝定界利用一个队列来记录活节点，节点将按照</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>顺序从队列中取出；而最大收益分枝定界使用一个最大堆，其中的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点按照每个活节点收益值的降序，或是按照活节点任意子树的叶节点所能获得的收益估计值的降序从队列中取出。本例所使用的背包问题与例</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 . 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>相同，并且有相同的解空间树。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>使用</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I
F O</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>分枝定界法搜索，初始时以根节点</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>A</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>作为</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点，此时活节点队列为空。当节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>A</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>展开时，生成了节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，由于这两个节点都是可行的，因此都被加入活节点队列中，节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被删除。下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，展开它并产生了节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是不可行的，被删除，而</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被加入队列中。下一步节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，它展开后生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>G</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，两者都是可行节点，加入队列中。下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>不可行而被删除，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是一个可行的叶节点，并产生一个到目前为止可行的解，它的收益值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>4 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>下一个</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点是</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>F</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，它产生两个孩子</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>L</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>代表一个可行的解且其收益值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>5 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>代表另一个收益值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的可行解。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>G</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是最后一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，它的孩子</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>都是可行的。由于活节点队列变为空，因此搜索过程终止，最佳解的收益值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>5 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>可以看到，工作在解空间树上的</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界方法非常象从根节点出发的宽度优先搜索。它们的主要区别是在</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界中不可行的节点不会被搜索。最大收益分枝定界算法以解空间树中的节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>作为初始节点。展开初始节点得到节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，两者都是可行的并被插入堆中，节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>获得的收益值是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>4 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（设</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span></i><span lang=EN-US
style='font-size:5.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 </span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>= 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>），而节点</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>C</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>得到的收益值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被删除，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，因为它的收益值比</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的大。当展开</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>时得到了节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是不可行的而被删除，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>加入堆中。由于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>具有收益值</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>4 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，而</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，因为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>展开</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>时生成节点</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>J</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>不可行而被删除，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是一个可行的解，因此</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为作为目前能找到的最优解而记录下来，然后</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被删除。由于只剩下一个活节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>在堆中，因此</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>作为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点被展开，生成</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>G</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>两个节点插入堆中。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的收益值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，因此成为下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，展开后得到节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，但</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>都被删除，因为它们是叶节点，同时</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所对应的解被作为当前最优解记录下来。最终，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>G</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，生成的节点为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，两者都是叶节点而被删除，两者所对应的解都不比当前的最优解更好，因此最优解保持不变。此时堆变为空，没有下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点产生，搜索过程终止。终止于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的搜索即为最优解。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>犹如在回溯方法中一样，可利用一个定界函数来加速最优解的搜索过程。定界函数为最大收益设置了一个上限，通过展开一个特殊的节点可能获得这个最大收益。如果一个节点的定界函数值不大于目前最优解的收益值，则此节点会被删除而不作展开，更进一步，在最大收益分枝定界方法中，可以使节点按照它们收益的定界函数值的非升序从堆中取出，而不是按照节点的实际收益值来取出。这种策略从可能到达一个好的叶节点的活节点出发，而不是从目前具有较大收益值的节点出发。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>例<span lang=EN-US>5</span></span><span
lang=EN-US style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>-3 [</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>旅行商问题</span><span
lang=EN-US style='font-size:10.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>] </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>对于图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的四城市旅行商问题，其对应的解空间为图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所示的排列树。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界使用节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>作为初始的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，活节点队列初始为空。当</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>展开时，生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。由于从顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>都有边相连，所以</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>三个节点都是可行的并加入队列中。当前的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被删除，新的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是队列中的第一个节点，即节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。因为在图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中存在从顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的边，因此展开</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>G</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，两者都被加入队列。下一步，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，接着又是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，到目前为止活节点队列中包含节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，展开它得到了叶节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。至此找到了一个旅行路径，它的开销是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>5 9</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。展开下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>G</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，得到叶节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，它对应于一个开销为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>6 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的旅行路径。接着</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，从而找到叶节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，对应开销为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的旅行路径。下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>I</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，它对应的部分旅行</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 - 3 - 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的开销已经为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，超过了目前最优的旅行路径，因此， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>I</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>不会被展开。最后，节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点并被展开。经过这些展开过程，队列变为空，算法结束。找到的最优方案是节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所对应的旅行路径。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>如果不使用</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>方法，还可以使用最小耗费方法来搜索解空间树，即用一个最小堆来存储活节点。这种方法同样从节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>开始搜索，并使用一个空的活节点列表。当节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>展开时，生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>并将它们加入最小堆中。在最小堆的节点中， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>具有最小耗费（因为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 - 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的局部旅行的耗费是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>），因此成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。展开</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>并将它们加入最小堆，这两个节点的耗费分别为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。此时，在所有最小堆的节点中，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>D</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>具有最小耗费，因而成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，并生成节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>I</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。至此，最小堆中包含节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>I</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>、</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>具有最小耗费，因此</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>成为下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。展开节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，得到一个完整的旅行路径</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 - 3 - 2 - 4 - 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，它的开销是</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2 5</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>J</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，展开它得到节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>P</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，它对应于一个耗费为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>2 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的旅行路径。节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>K</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>I</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是下两个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。由于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>I</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的开销超过了当前最优的旅行路径，因此搜索结束，而剩下的所有活节点都不能使我们找到更优的解。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>对于例<span lang=EN-US>5</span></span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'> - 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的背包问题，可以使用一个定界函数来减少生成和展开的节点数量。这种函数将确定旅行的最小耗费的下限，这个下限可通过展开某个特定的节点而得到。如果一个节点的定界函数值不能比当前的最优旅行更小，则它将被删除而不被展开。另外，对于最小耗费分枝定界，节点按照它在最小堆中的非降序取出。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>在以上几个例子中，可以利用定界函数来降低所产生的树型解空间的节点数目。当设计定界函数时，必须记住主要目的是利用最少的时间，在内存允许的范围内去解决问题。而通过产生具有最少节点的树来解决问题并不是根本的目标。因此，我们需要的是一个能够有效地减少计算时间并因此而使产生的节点数目也减少的定界函数。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>回溯法比分枝定界在占用内存方面具有优势。回溯法占用的内存是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（解空间的最大路径长度），而分枝定界所占用的内存为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（解空间大小）。对于一个子集空间，回溯法需要</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>(<i>n</i>)</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的内存空间，而分枝定界则需要</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>O ( 2</span><i><span lang=EN-US
style='font-size:5.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>n </span></i><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>) </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的空间。对于排列空间，回溯需要</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>(<i>n</i>) </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的内存空间，分枝定界需要</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>O (<i>n</i>!) </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的空间。虽然最大收益（或最小耗费）分枝定界在直觉上要好于回溯法，并且在许多情况下可能会比回溯法检查更少的节点，但在实际应用中，它可能会在回溯法超出允许的时间限制之前就超出了内存的限制。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:12.0pt;
mso-char-indent-count:1.0;mso-char-indent-size:12.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:12.0pt;font-family:仿宋_GB2312;
color:blue;mso-font-kerning:0pt'>练习<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>假定在一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界搜索中，活节点列表的行为与堆栈相同，请使用这种方法来解决例<span
lang=EN-US>5</span></span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'> - 2</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的背包问题。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界与回溯有何区别？<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>对于如下</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0 / 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>背包问题：</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span></i><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>=4, <i>p</i>=[4,3,2,1], <i>w</i>=[1,2,3,4], <i>c </i>=6</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>画出有四个对象的背包问题的解空间树。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>像例</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>那样，描述用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界法解决上述问题的过程。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>3) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B o u n d</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>函数来计算子树上任一叶节点可能获得的最大收益值，并根据每一步所能得到的最优解对应的定界函数值来判断是否将节点加入活节点列表中。解空间中哪些节点是使用以上机制的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界方法产生的？<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>4) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>像例</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>那样，描述用最大收益分枝定界法解决上述问题的过程。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>5) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>在最大收益分枝定界中，若使用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）中的定界函数，将产生解空间树中的哪些节点？<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:12.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:12.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.2 </span><span
style='font-size:12.0pt;font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>应用<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.2.1 </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>货箱装船<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1. FIFO</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>分枝定界<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:10.0pt;
mso-char-indent-count:1.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>4 . 2 . 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>节的货箱装船问题主要是寻找第一条船的最大装载方案。这个问题是一个子集选择<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>问题，它的解空间被组织成一个子集树。对程序</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 6 - 1</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>进行改造，即得到程序</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 7 - 1</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>中的</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界代码。程序</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 7 - 1</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>只是寻找最大装载的重量。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-1 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>货箱装船问题的</span><span lang=EN-US
style='font-size:9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:9.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界算法<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>void
AddLiveNode(LinkedQueue&lt;T&gt; &amp;Q, T wt,<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T&amp;
bestw, int i, int n)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>如果不是叶节点，则将节点权值</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>w t</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>加入队列</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if (i
== n) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(wt &gt; bestw) bestw = wt;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>else
Q.Add(wt); // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>不是叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
MaxLoading(T w[], T c, int n)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>返回最优装载值<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界算法<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为层次</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>LinkedQueue&lt;T&gt;
Q; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>活节点队列<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Add(-1);
//</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>标记本层的尾部<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int i
= 1; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T Ew
= 0, // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的权值<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestw
= 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>目前的最优值<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索子集空间树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(true) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的左孩子<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Ew + w[i] &lt;= c) // x[i] = 1<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(Q,
Ew + w[i], bestw, i, n);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>右孩子总是可行的<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(Q,
Ew, bestw, i, n); // x[i] = 0<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Delete(Ew);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>取下一个</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Ew == -1) { // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>到达层的尾部<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Q.IsEmpty()) return bestw;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Add(-1);
//</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>添加尾部标记<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Delete(Ew);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>取下一个</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>i++;}
// Ew</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>的层<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>其中函数</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MaxLoading
</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>在解空间树中进行分枝定界搜索。链表队列</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>Q</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>用于保存活节点，其中记录着各活节点对应的权值。队列还记录了权值</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>- 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，以标识每一层的活节点的结尾。函数</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>AddLiveNode </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用于增加节点（即把节点对应的权值加入活节点队列），该函数首先检验</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（当前</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点在解空间树中的层）是否等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，如果相等，则已到达了叶节点。叶节点不被加入队列中，因为它们不被展开。搜索中所到达的每个叶节点都对应着一个可行的解，而每个解都会与目前的最优解来比较，以确定最优解。如果</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span></i><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>＜</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span></i><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，则节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>就会被加入队列中。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a x L o a d i n g</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>函数首先初始化</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i = 1</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（因为当前</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是根节点），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w = 0</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（目前最优解的对应值），此时，活节点队列为空。下一步，
</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A - 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被加入队列以说明正处在第一层的末尾。当前</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点对应的权值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
5.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>w</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。在</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>while </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环中，首先检查节点的左孩子是否可行。如果可行，则调用</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v
e N o d e</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>，然后将右孩子加入队列（此节点必定是可行的），注意到</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>A d d l i v e N o d e</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>可能会失败，因为可能没有足够的内存来给队列增加节点。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>并没有去捕获</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . A d d</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>中的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>N o M e m</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>异常，这项工作留给用户完成。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>如果</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点的两个孩子都已经被生成，则删除该</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。从队列中取出下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，此时队列必不为空，因为队列中至少含有本层末尾的标识-
</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。如果到达了某一层的结尾，则从下一层寻找活节点，当且仅当队列不为空时这些节点存在。当下一层存在活节点时，向队列中加入下一层的结尾标志并开始处理下一层的活节点。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a x L o a d i n g</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>函数的时间和空间复杂性都是</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>O ( 2</span><i><span lang=EN-US
style='font-size:5.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>n </span></i><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>)</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>改进<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>我们可以尝试使用程序</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 6 - 2</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>的优化方法改进上述问题的求解过程。在程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中，只有当右孩子对应的重量加上剩余货箱的重量超出</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>时，才选择右孩子。而在程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中，在</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>变为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>之前，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值一直保持不变，因此在</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>之前对右孩子的测试总能成功，因为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w = 0</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>且</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>r &gt; 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。当</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>时，不会再有节点加入队列中，因此这时对右孩子的测试不再有效。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>如想要使右孩子的测试仍然有效，应当提早改变</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值。我们知道，最优装载的重量是子集树中可行节点的重量的最大值。由于仅在向左子树移动时这些重量才会增大，因此可以在每次进行这种移动时改变</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值。根据以上思想，我们设计了程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。当活节点加入队列时，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>w t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>不会超过</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，故</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>不用更新。因此用一条直接插入</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M a x L o a d i n g</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的简单语句取代了函数</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-2 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>对程序</span><span lang=EN-US
style='font-size:9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 1</span><span style='font-size:9.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>改进之后<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
MaxLoading(T w[], T c, int n)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>返回最优装载值<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界算法<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为层</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>LinkedQueue&lt;T&gt;
Q; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>活节点队列<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . A
d d ( - 1 ) ; / /</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>标记本层的尾部<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int i
= 1; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T Ew
= 0, // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestw
= 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>目前的最优值<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r =
0; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点中余下的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 2; j &lt;= n; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r +=
w[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索子集空间树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(true) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的左孩子<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T wt
= Ew + w[i]; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>左孩子的权值<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(wt &lt;= c) { // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>可行的左孩子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(wt &gt; bestw) bestw = wt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>若不是叶子，则添加到队列中<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if (i
&lt; n) Q.Add(wt);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查右孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Ew + r &gt; bestw &amp;&amp; i &lt; n)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Add(Ew);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>可以有一个更好的叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Delete(Ew);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>取下一个</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Ew == -1) { // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>到达层的尾部<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Q.IsEmpty()) return bestw;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Add(-1);
//</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>添加尾部标记<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q.Delete(Ew);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>取下一个</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>i++;
// E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r -=
w[i];} // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点中余下的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>3. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>寻找最优子集<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>为了找到最优子集，需要记录从每个活节点到达根的路径，因此在找到最优装载所对应的叶节点之后，就可以利用所记录的路径返回到根节点来设置</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值。活节点队列中元素的类型是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>Q N o d e (</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 3 )</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。这里，当且仅当节点是它的父节点的左孩子时， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>L C h i l d</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>t r u e</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-3 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>类</span><span lang=EN-US
style='font-size:9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>Q N o d e<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>class
QNode {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>p r i
v a t e :<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>QNode
*parent; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>父节点指针<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bool
LChild; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>当且仅当是父节点的左孩子时，取值为</span><span lang=EN-US
style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>t r u e<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
weight; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>由到达本节点的路径所定义的部分解的值<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>} ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 4</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>是新的分枝定界方法的代码。为了避免使用大量的参数来调用</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>A d d L i v e N o d e</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，可以把该函数定义为一个内部函数。使用内部函数会使空间需求稍有增加。此外，还可以把</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>和</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a x L o a d i n g</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>定义成类成员函数，这样，它们就可以共享诸如</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q , i , n ,
b e s t w, E , b e s t E</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>和</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestw
</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>等类成员。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 4</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>并未删除类型为</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的节点。为了删除这些节点，可以保存由</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v
e N o d e</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>创建的所有节点的指针，以便在程序结束时删除这些节点。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-4 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>计算最优子集的分枝定界算法<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>void
AddLiveNode(LinkedQueue&lt;QNode&lt;T&gt;*&gt; &amp;Q, T wt, int i, int n, T
bestw, QNode&lt;T&gt; *E,<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>QNode&lt;T&gt;
*&amp;bestE, int bestx[], bool ch)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>如果不是叶节点，则向队列</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中添加一个</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>层、重量为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>w t</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的活节点<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>新节点是</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的一个孩子。当且仅当新节点是左孩子时，
</span><span lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c h</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>t r u e</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>若是叶子，则</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c h</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>取值为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t x [ n ]<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if (i
== n) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(wt == bestw) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>目前的最优解<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestE
= E;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[n]
= ch;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r e t
u r n ; }<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>不是叶子</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>, </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>添加到队列中<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>QNode&lt;T&gt;
*b;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b = new
QNode&lt;T&gt;;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b-&gt;weight
= wt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b-&gt;parent
= E;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b-&gt;LChild
= ch;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . A
d d ( b ) ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
MaxLoading(T w[], T c, int n, int bestx[])<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>返回最优装载值，并在</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t x</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中返回最优装载<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界算法<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化层</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>LinkedQueue&lt;QNode&lt;T&gt;*&gt;
Q; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>活节点队列<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . A
d d ( 0 ) ; // 0 </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>代表本层的尾部<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int i
= 1; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T Ew
= 0, // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestw
= 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>迄今得到的最优值<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r =
0; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点中余下的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 2; j &lt;= n; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r +=
w[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>QNode&lt;T&gt;
*E = 0, // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>当前的</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>* b e
s t E ; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>目前最优的</span><span lang=EN-US
style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索子集空间树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(true) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的左孩子<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T wt
= Ew + w[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if (wt
&lt;= c) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>可行的左孩子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(wt &gt; bestw) bestw = wt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(Q,
wt, i, n, bestw, E, bestE, bestx, true);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查右孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Ew + r &gt; bestw) AddLiveNode(Q, Ew, i, n, bestw, E, bestE, bestx, false);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . D
e l e t e ( E ) ; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>下一个</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(!E) { // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>层的尾部<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Q.IsEmpty()) break;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . A
d d ( 0 ) ; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>层尾指针<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q . D
e l e t e ( E ) ; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>下一个</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>i + +
; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层次<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r -=
w[i];} // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点中余下的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Ew =
E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>&gt; w e i g h t ; // </span><span style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>新的</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>沿着从</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t E</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到根的路径构造</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x[ ] </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>， </span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x [ n ]</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>由</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>来设置<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(j = n - 1; j &gt; 0; j--) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[j]
= bestE</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>&gt;LChild; // </span><span style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>从</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b o o l</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>转换为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i n t<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestE
= bestE</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>&gt; p a r e n t ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>return
bestw;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>4. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>最大收益分枝定界<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>在对子集树进行最大收益分枝定界搜索时，活节点列表是一个最大优先级队列，其中每个活节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>都有一个相应的重量上限（最大收益）。这个重量上限是节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>相应的重量加上剩余货箱的总重量，所有的活节点按其重量上限的递减顺序变为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。需要注意的是，如果节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的重量上限是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x . u w e i g h t</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，则在子树中不可能存在重量超过</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x.uweight </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的节点。另外，当叶节点对应的重量等于它的重量上限时，可以得出结论：在最大收益分枝定界算法中，当某个叶节点成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点并且其他任何活节点都不会帮助我们找到具有更大重量的叶节点时，最优装载的搜索终止。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>上述策略可以用两种方法来实现。在第一种方法中，最大优先级队列中的活节点都是互相独立的，因此每个活节点内部必须记录从子集树的根到此节点的路径。一旦找到了最优装载所对应的叶节点，就利用这些路径信息来计算</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值。在第二种方法中，除了把节点加入最大优先队列之外，节点还必须放在另一个独立的树结构中，这个树结构用来表示所生成的子集树的一部分。当找到最大装载之后，就可以沿着路径从叶节点一步一步返回到根，从而计算出</span><i><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x </span></i><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>最大优先队列可用</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>HeapNode </span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>类型的最大堆来表示（见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>uweight </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是活节点的重量上限，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>level </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是活节点所在子集树的层， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>ptr </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是指向活节点在子集树中位置的指针。子集树中节点的类型是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b b n o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）。节点按</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u w e i g h t</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值从最大堆中取出。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-5 bbnode </span><span style='font-size:9.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:9.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>HeapNode </span><span
style='font-size:9.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>类<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>class
bbnode {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>p r i
v a t e :<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bbnode
*parent; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>父节点指针<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bool
LChild; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>当且仅当是父节点的左孩子时，取值为</span><span lang=EN-US
style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>t r u e<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>} ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>class
HeapNode {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>p u b
l i c :<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>operator
T () const {return uweight;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>p r i
v a t e :<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bbnode
*ptr; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>活节点指针<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
uweight; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>活节点的重量上限<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
level; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>活节点所在层<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>} ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 6</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>中的函数</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v
e N o d e</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>用于把</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b b n o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>类型的活节点加到子树中，并把</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>H e a p N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>类型的活节点插入最大堆。</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>必须被定义为</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b b n o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>和</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>H e a p N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的友元。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-6<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>void
AddLiveNode(MaxHeap&lt;HeapNode&lt;T&gt; &gt; &amp;H, bbnode *E, T wt, bool ch,
int lev)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>向最大堆</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>H</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中增添一个层为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>l e v</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>上限重量为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>w t</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的活节点<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>新节点是</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的一个孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>当且仅当新节点是左孩子</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>ch </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>t r u e<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bbnode
*b = new bbnode;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b-&gt;parent
= E;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b-&gt;LChild
= ch;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>HeapNode&lt;T&gt;
N;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.uweight
= wt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.level
= lev;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.ptr
= b;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H . I
n s e r t ( N ) ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
MaxLoading(T w[], T c, int n, int bestx[])<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>返回最优装载值，最优装载方案保存于</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t x<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用最大收益分枝定界算法<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>定义一个最多有</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0 0 0</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>个活节点的最大堆<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MaxHeap&lt;HeapNode&lt;T&gt;
&gt; H(1000);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>第一剩余重量的数组<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>//
r[j] </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>为</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>w [ j + 1 : n ]</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的重量之和<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T *r
= new T [n+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r[n]
= 0;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = n-1; j &gt; 0; j--)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>r[j]
= r[j+1] + w[j+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化层</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int i
= 1; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bbnode
*E = 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>当前</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T Ew
= 0; // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的重量<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索子集空间树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(i != n+1) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>不在叶子上<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的孩子<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Ew + w[i] &lt;= c) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>可行的左孩子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(H,
E, Ew+w[i]+r[i], true, i+1);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>右孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(H,
E, Ew+r[i], false, i+1);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>取下一个</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>HeapNode&lt;T&gt;
N;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H.DeleteMax(N);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>不能为空<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>i =
N.level;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E =
N.ptr;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Ew =
N.uweight - r[i-1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>沿着从</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到根的路径构造</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t x [ ]<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = n; j &gt; 0; j--) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[j]
= E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>&gt;LChild; // </span><span style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>从</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b o o l</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>转换为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i n t<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E = E</span><span
lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-</span><span lang=EN-US style='font-size:8.0pt;font-family:Arial;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>&gt; p a r
e n t ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>return
Ew;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>函数</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a
x L o a d i n g</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>（见程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 6</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>）首先定义了一个容量为</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0 0 0</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的最大堆，因此，可以用它来解决优先队列中活节点数在任何时候都不超过</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0
0 0</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>的装箱问题。对于更大型的问题，需要一个容量更大的最大堆。接着，函数</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>M a x L o a d i n g</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化剩余重量数组</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>r</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。第</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i + 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>层的节点（即</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x [ 1 : i ]</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值都已确定）对应的剩余容器总重量可以用如下公式求出：<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:10.0pt;
mso-char-indent-count:1.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'><span style="mso-spacerun:
yes">&nbsp;</span></span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>r [i]=</span><span lang=EN-US
style='font-size:5.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>n </span><span lang=EN-US style='font-size:10.0pt;
font-family:Symbol;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>&aring;</span><span lang=EN-US style='font-size:5.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>j=i + 1</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>w[ j ]</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:10.0pt;
mso-char-indent-count:1.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>变量</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>指向子集树中的当前</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点，</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>Ew </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是该节点对应的重量， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是它所在的层。初始时，根节点是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，因此取</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i=1, Ew=0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。由于没有明确地存储根节点，因此</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的初始值取为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>while </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>循环用于产生当前</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的左、右孩子。如果左孩子是可行的（即它的重量没有超出容量），则将它加入到子集树中并作为一个第</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i + 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>层节点加入最大堆中。一个可行的节点的右孩子也被认为是可行的，它总被加入子树及最大堆中。在完成添加操作后，接着从最大堆中取出下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。如果没有下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，则不存在可行的解。如果下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点是叶节点（即是一个层为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n + 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的节点），则它代表着一个最优的装载，可以沿着从叶到根的路径来确定装载方案。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>5. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>说明<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用最大堆来表示活节点的最大优先队列时，需要预测这个队列的最大长度（程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 6<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>中是</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0
0 0</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>）。为了避免这种预测，可以使用一个基于指针的最大优先队列来取代基于数组的队列，这种表示方法见</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>9 . 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>节的左高树。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2) bestw</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>表示当前所有可行节点的重量的最大值，而优先队列中可能有许多其</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>u w
e i g h t</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>不超过</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t w</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的活节点，因此这些节点不可能帮助我们找到最优的叶节点，这些节点浪费了珍贵的队列空间，并且它们的插入</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>/</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>删除动作也浪费了时间，所以可以将这些节点删除。有一种策略可以减少这种浪费，即在插入某个节点之前检查是否有</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u w e i g h t &lt; b e s t w</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。然而，由于</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t w</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>在算法执行过程中是不断增大的，所以目前插入的节点在以后并不能保证</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>u w
e i g h t &lt; b e s t w</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。另一种更好的方法是在每次</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>增大时，删除队列中所有</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>u w e i g h t &lt; b e s e w</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的节点。这种策略要求删除具有最小</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>u w e i g h
t</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>的节点。因此，队列必须支持如下的操作：插入、删除最大节点、删除最小节点。这种优先队列也被称作双端优先队列（ </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>double-ended priority queue</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>）。这种队列的数据结构描述见第</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>9</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>章的参考文献。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.2.2<span
style="mso-spacerun: yes">&nbsp; </span>0/1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>背包问题<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>0 / 1</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>背包问题的最大收益分枝定界算法可以由程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>发展而来。可以使用程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B o u n d</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>函数来计算活节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的收益上限</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u p ,</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使得以</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为根的子树中的任一节点的收益值都不可能超过</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u p r o f i t</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。活节点的最大堆使用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u p r o f i t</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>作为关键值域，最大堆的每个入口都以</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H e a p N o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>作为其类型，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H e a p N o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>有如下私有成员：</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>uprofit, profit, weight</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>l e v e l</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>p t r</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，其中</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l e v e l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>p t r</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的定义与装箱问题（见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）中的含义相同。对任一节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N . p r o f i t</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的收益值，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N uprofit</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是它的收益上限， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N. weight </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是它对应的重量。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b b n o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>类型如程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中的定义，各节点按其</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u p r o f i t</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值从最大堆中取出。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 7</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>使用了类</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Knap, </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>它类似于回溯法中的类</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>K n a p</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>（见程序</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 6 - 5</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>）。两个</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>K n a p</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>版本中数据成员之间的区别见程序</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7 - 7</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>：</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1) bestp </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>不再是一个成员； </span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2) bestx </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>是一个指向</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>int </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的新成员。新增成员的作用是：当且仅当物品</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>j </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>包含在最优解中时， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t x [ j ] = 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。函数</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用于将新的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b b n o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>类型的活节点插入子集树中，同时将</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H e a p N o
d e</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>类型的活节点插入到最大堆中。这个函数与装箱问题（见程序</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 7 - 6</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>）中的对应函数非常类似，因此相应的代码被省略。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-7 0/1</span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>背包问题的最大收益分枝定界算法<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
Tw, class Tp&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Tp
Knap&lt;Tw, Tp&gt;::MaxProfitKnapsack()<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>返回背包最优装载的收益<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>//
bestx[i] = 1 </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>当且仅当物品</span><span lang=EN-US
style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>属于最优装载<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用最大收益分枝定界算法<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>定义一个最多可容纳</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0 0 0</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>个活节点的最大堆<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H =
new MaxHeap&lt;HeapNode&lt;Tp, Tw&gt; &gt; (1000);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t x</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分配空间<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx
= new int [n+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化层</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int i
= 1;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E =
0;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>cw =
cp = 0;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Tp
bestp = 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>目前的最优收益<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Tp up
= Bound(1); // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>在根为</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的子树中最大可能的收益<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索子集空间树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(i != n+1) { // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>不是叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查左孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Tw wt
= cw + w[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(wt &lt;= c) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>可行的左孩子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(cp+p[i] &gt; bestp) bestp = cp+p[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(up,
cp+p[i], cw+w[i], true, i+1);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>up =
Bound(i+1);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查右孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(up &gt;= bestp) // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>右孩子有希望<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddLiveNode(up,
cp, cw, false, i+1);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>取下一个</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>HeapNode&lt;Tp,
Tw&gt; N;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H-&gt;DeleteMax(N);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>不能为空<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E =
N.ptr;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>cw =
N.weight;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>cp =
N.profit;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>up =
N.uprofit;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>i =
N.level;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>沿着从</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到根的路径构造</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[]<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = n; j &gt; 0; j--) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[j]
= E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>&gt; L C h i l d ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E = E</span><span
lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-</span><span lang=EN-US style='font-size:8.0pt;font-family:Arial;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>&gt; p a r
e n t ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>return
cp;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>函数</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a
x P r o f i t K n a p s a c k</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>在子集树中执行最大收益分枝定界搜索。函数假定所有的物品都是按收益密度值的顺序排列，可以使用类似于程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 9</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中回溯算法所使用的预处理代码来完成这种排序。函数</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M a x P r o f i t K n a p s a c k</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>首先初始化活节点的最大堆，并使用一个数组</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t x</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>来记录最优解。由于需要不断地利用收益密度来排序，物品的索引值会随之变化，因此必须将</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>M a x P r o f i t K n a p s a c k</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>所生成的结果映射回初始时的物品索引。可以用</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Q</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>I D</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>域来实现上述映射（见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 9</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>在函数</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a
x P r o f i t K n a p S a c k</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>中，</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>是当前</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点，</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>c w</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>是节点对应的重量， </span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c p</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是收益值，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u p</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是以</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为根的子树中任一节点的收益值上限。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>w h i l e</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>循环一直执行到一个叶节点成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点为止。由于最大堆中的任何剩余节点都不可能具有超过当前叶节点的收益值，因此当前叶即对应了一个最优解。可以从叶返回到根来确定这个最优解。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a x P r o f i t K n a p s a c k</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>中</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>w h i l e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环的结构很类似于程序</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7 - 6</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>w h i l e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环。首先，检验</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点左孩子的可行性，如它是可行的，则将它加入子集树及活节点队列（即最大堆）；仅当节点右孩子的</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>B o u n d</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>值指明有可能找到一个最优解时才将右孩子加入子集树和队列中。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.2.3 </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>最大完备子图<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>4 . 2 . 3</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>节完备子图问题的解空间树也是一个子集树，故可以使用与装箱问题、背包问题相同的最大收益分枝定界方法来求解这种问题。解空间树中的节点类型为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b b n o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，而最大优先队列中元素的类型则是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C l i q u e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>C l i q u e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>有如下域：</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（该节点对应的完备子图中的顶点数目），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（该节点的子树中任意叶节点所对应的完备子图的最大尺寸），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l e v e l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（节点在解空间树中的层），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（当且仅当该节点是其父节点的左孩子时， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>p t r</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（指向节点在解空间树中的位置）。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c n + n - l e v e + 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。因为根据</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>un </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（或</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l e v e l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）可以求出</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l e v e l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（或</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>），所以可以去掉</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>或</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l e v e l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>域。当从最大优先队列中选取元素时，选取的是具有最大</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值的元素。在程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 8</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C l i q u e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>包含了所有的三个域：</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>un </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l e v e l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，这样便于尝试为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>赋予不同的含义。函数</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A d d C l i q u e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用于向生成的子树和最大堆中加入节点，由于其代码非常类似于装箱和背包问题中的对应函数，故将它略去。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>函数</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>B B
M a x C l i q u e</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>在解空间树中执行最大收益分枝定界搜索，树的根作为初始的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，该节点并没有在所构造的树中明确存储。对于这个节点来说，其</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>cn </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点对应的完备子图的大小）为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，因为还没有任何顶点被加入完备子图中。</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的层由变量</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>指示，它的初值为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，对应于树的根节点。当前所找到的最大完备子图的大小保存在</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>在</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>循环中，不断展开</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点直到一个叶节点变成</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点。对于叶节点，</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>u n</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>＝</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c n</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。由于所有其他节点的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>un </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值都小于等于当前叶节点对应的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>un </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值，所以它们不可能产生更大的完备子图，因此最大完备子图已经找到。沿着生成的树中从叶节点到根的路径，即可构造出这个最大完备子图。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>为了展开一个非叶</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，应首先检查它的左孩子，如果左孩子对应的顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>与当前</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点所包含的所有顶点之间都有一条边，则</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被加入当前的完备子图之中。为了检查左孩子的可行性，可以沿着从</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点到根的路径，判断哪些顶点包含在</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点之中，同时检查这些顶点中每个顶点是否都存在一条到</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的边。如果左孩子是可行的，则把它加入到最大优先队列和正在构造的树中。下一步，如果右孩子的子树中包含最大完备子图对应的叶节点，则把右孩子也加入。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>由于每个图都有一个最大完备子图，因此从堆中删除节点时，不需要检验堆是否为空。仅当到达一个可行的叶节点时，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>w h i l e</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>循环终止。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-8 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>最大完备子图问题的分枝定界算法<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
AdjacencyGraph::BBMaxClique(int bestx[])<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>寻找一个最大完备子图的最大收益分枝定界程序<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>定义一个最多可容纳</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0 0 0</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>个活节点的最大堆<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MaxHeap&lt;CliqueNode&gt;
H(1000);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化层</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bbnode
*E = 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>当前的</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点为根<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int i
= 1, // E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的层<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>cn =
0, // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>完备子图的大小<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestn
= 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>目前最大完备子图的大小<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索子集空间树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(i != n+1) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>不是叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>在当前完备子图中检查顶点</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是否与其它顶点相连<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bool
OK = true;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bbnode
*B = E;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = i - 1; j &gt; 0; B = B-&gt;parent, j--)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(B-&gt;LChild &amp;&amp; a[i][j] == NoEdge) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>OK =
false;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>b r e
a k ; }<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(OK) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>左孩子可行<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(cn + 1 &gt; bestn) bestn = cn + 1;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddCliqueNode(H,
cn+1, cn+n-i+1, i+1, E, true);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(cn + n - i &gt;= bestn)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>右孩子有希望<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>AddCliqueNode(H,
cn, cn+n-i, i+1, E, false);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>取下一个</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>CliqueNode
N;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H.DeleteMax(N);
// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>不能为空<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E =
N.ptr;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>cn =
N.cn;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>i =
N.level;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>沿着从</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到根的路径构造</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[]<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = n; j &gt; 0; j--) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx[j]
= E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>&gt; L C h i l d ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E = E</span><span
lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-</span><span lang=EN-US style='font-size:8.0pt;font-family:Arial;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>&gt; p a r
e n t ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>return
bestn;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.2.4 </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>旅行商问题<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>旅行商问题的介绍见<span lang=EN-US>4</span></span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'> . 2 . 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>节，它的解空间是一个排列树。与在子集树中进行最大收益和最小耗费分枝定界搜索类似，该问题有两种实现的方法。第一种是只使用一个优先队列，队列中的每个元素中都包含到达根的路径。另一种是保留一个部分解空间树和一个优先队列，优先队列中的元素并不包含到达根的路径。本节只实现前一种方法。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>由于我们要寻找的是最小耗费的旅行路径，因此可以使用最小耗费分枝定界法。在实现过程中，使用一个最小优先队列来记录活节点，队列中每个节点的类型为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M i n H e a p N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。每个节点包括如下区域： </span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（从</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的整数排列，其中</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x [ 0 ] = 1 )</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>s</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（一个整数，使得从排列树的根节点到当前节点的路径定义了旅行路径的前缀</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x[0:s], </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>而剩余待访问的节点是</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x [ s + 1 : n - 1 ]</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>），</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c c</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（旅行路径前缀，即解空间树中从根节点到当前节点的耗费），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l c o s t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（该节点子树中任意叶节点中的最小耗费）， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>r c o s t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（从顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x [ s : n - 1 ]</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>出发的所有边的最小耗费之和）。当类型为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>M i n H e a p N o d e ( T )</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的数据被转换成为类型</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>T</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>时，其结果即为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l c o s t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值。分枝定界算法的代码见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 9</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 9</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>首先生成一个容量为</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0 0 0</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的最小堆，用来表示活节点的最小优先队列。活节点按其</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>l c o s t</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>值从最小堆中取出。接下来，计算有向图中从每个顶点出发的边中耗费最小的边所具有的耗费</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>M i n O u t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。如果某些顶点没有出边，则有向图中没有旅行路径，搜索终止。如果所有的顶点都有出边，则可以启动最小耗费分枝定界搜索。根的孩子（图</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 6 - 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）作为第一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，在此节点上，所生成的旅行路径前缀只有一个顶点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，因此</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>s=0, x[0]=1, x[1:n-1]</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>是剩余的顶点（即顶点</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2 </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>3 </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，<span lang=EN-US>.， </span></span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>）。旅行路径前缀</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的开销为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0 </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，即</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c c = 0 </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，并且，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>r c o st=</span><span lang=EN-US
style='font-size:5.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>n </span><span lang=EN-US style='font-size:12.0pt;
font-family:Symbol;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>&aring;</span><span lang=EN-US style='font-size:5.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i=1</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>M i n O u t [i]</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。在程序中，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bestc </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>给出了当前能找到的最少的耗费值。初始时，由于没有找到任何旅行路径，因此</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t c</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值被设为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N o E d g e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-9 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>旅行商问题的最小耗费分枝定界算法<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>template&lt;class
T&gt;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
AdjacencyWDigraph&lt;T&gt;::BBTSP(int v[])<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>旅行商问题的最小耗费分枝定界算法<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>定义一个最多可容纳</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 0 0 0</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>个活节点的最小堆<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinHeap&lt;MinHeapNode&lt;T&gt;
&gt; H(1000);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
*MinOut = new T [n+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>计算</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinOut[i] = </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>离开顶点</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>i</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的最小耗费边的耗费<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
MinSum = 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>离开顶点</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>i</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的最小耗费边的数目<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int i = 1; i &lt;= n; i++) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T Min
= NoEdge;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 1; j &lt;= n; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if (a[i][j]
!= NoEdge &amp;&amp;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>(a[i][j]
&lt; Min || Min == NoEdge))<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>Min =
a[i][j];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(Min == NoEdge) return NoEdge; // </span><span style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>此路不通<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinOut[i]
= Min;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinSum
+= Min;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>把</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点初始化为树根<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinHeapNode&lt;T&gt;
E;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.x =
new int [n];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(i = 0; i &lt; n; i++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.x[i]
= i + 1;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.s =
0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>局部旅行路径为</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>x [ 1 : 0 ]<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.cc
= 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>其耗费为</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>0<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.rcost
= MinSum;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
bestc = NoEdge; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>目前没有找到旅行路径<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>搜索排列树<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(E.s &lt; n - 1) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>不是叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(E.s == n - 2) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>叶子的父节点<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>通过添加两条边来完成旅行<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>检查新的旅行路径是不是更好<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(a[E.x[n-2]][E.x[n-1]] != NoEdge &amp;&amp; a[E.x[n-1]][1] != NoEdge &amp;&amp;
(E.cc +<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>a[E.x[n-2]][E.x[n-1]]
+ a[E.x[n-1]][1] &lt; bestc || bestc == NoEdge)) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>找到更优的旅行路径<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestc
= E.cc + a[E.x[n-2]][E.x[n-1]] + a[E.x[n-1]][1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.cc
= bestc;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.lcost
= bestc;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E . s
+ + ;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H . I
n s e r t ( E ) ; }<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>else
delete [] E.x;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>else
{// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>产生孩子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int i = E.s + 1; i &lt; n; i++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(a[E.x[E.s]][E.x[i]] != NoEdge) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>可行的孩子</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>, </span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>限定了路径的耗费<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T cc
= E.cc + a[E.x[E.s]][E.x[i]];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T
rcost = E.rcost - MinOut[E.x[E.s]];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>T b =
cc + rcost; //</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>下限<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if (b
&lt; bestc || bestc == NoEdge) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>子树可能有更好的叶子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>把根保存到最大堆中<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinHeapNode&lt;T&gt;
N;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x =
new int [n];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 0; j &lt; n; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x[j]
= E.x[j];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x[E.s+1]
= E.x[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x[i]
= E.x[E.s+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.cc
= cc;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.s =
E.s + 1;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.lcost
= b;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.rcost
= rcost;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H . I
n s e r t ( N ) ; }<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>} // </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>结束可行的孩子<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>delete
[] E.x;} // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>对本节点的处理结束<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>try
{H.DeleteMin(E);} // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>取下一个</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>catch
(OutOfBounds) {break;} // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>没有未处理的节点<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(bestc == NoEdge) return NoEdge; // </span><span style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>没有旅行路径<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>将最优路径复制到</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>v[1:n] </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(i = 0; i &lt; n; i++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>v[i+1]
= E.x[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while
(true) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>释放最小堆中的所有节点<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>delete
[] E.x;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>try
{H.DeleteMin(E);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>catch
(OutOfBounds) {break;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>return
bestc;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>while </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环不断地展开</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点，直到找到一个叶节点。当</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>s = n - 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>时即可说明找到了一个叶节点。旅行路径前缀是</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>x [ 0 : n -
1 ]</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>，这个前缀中包含了有向图中所有的</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>n</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>个顶点。因此</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>s = n - 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的活节点即为一个叶节点。由于算法本身的性质，在叶节点上</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>lcost </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>和</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>cc </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>恰好等于叶节点对应的旅行路径的耗费。由于所有剩余的活节点的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>lcost </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值都大于等于从最小堆中取出的第一个叶节点的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>lcost </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值，所以它们并不能帮助我们找到更好的叶节点，因此，当某个叶节点成为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点后，搜索过程即终止。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>while </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环体被分别按两种情况处理，一种是处理</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>s = n - 2</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点，这时，</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点是某个单独叶节点的父节点。如果这个叶节点对应的是一个可行的旅行路径，并且此旅行路径的耗费小于当前所能找到的最小耗费，则此叶节点被插入最小堆中，否则叶节点被删除，并开始处理下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>其余的</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点都放在</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>while </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环的第二种情况中处理。首先，为每个</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点生成它的两个子节点，由于每个</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点代表着一条可行的路径</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x [ 0 : s ]</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，因此当且仅当</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>&lt; x[s],x[i] &gt; </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>是有向图的边且</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x [ i ]</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>是路径</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x [ s + 1 : n - 1 ]</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>上的顶点时，它的子节点可行。对于每个可行的孩子节点，将边</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>&lt;x[s],x[i]
&gt; </span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>的耗费加上</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.cc </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>即可得到此孩子节点的路径前缀</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>( x [ 0 : s ]</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x[i]) </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的耗费</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>c c</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。由于每个包含此前缀的旅行路径都必须包含离开每个剩余顶点的出边，因此任何叶节点对应的耗费都不可能小于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>cc </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>加上离开各剩余顶点的出边耗费的最小值之和，因而可以把这个下限值作为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点所生成孩子的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>lcost </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值。如果新生成孩子的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>lcost </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值小于目前找到的最优旅行路径的耗费</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t c</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，则把新生成的孩子加入活节点队列（即最小堆）中。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>如果有向图没有旅行路径，程序</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 7 - 9</span><span style='font-size:10.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>返回</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>N o E d g e</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>；否则，返回最优旅行路径的耗费，而最优旅行路径的顶点序列存储在数组</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>v </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>5.2.5 </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:blue;mso-font-kerning:0pt'>电路板排列<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>电路板排列问题（ </span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>1 6 . 2 . 5</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>节）的解空间是一棵排列树，可以在此树中进行最小耗费分枝定界搜索来找到一个最小密度的电路板排列。我们使用一个最小优先队列，其中元素的类型为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B o a r d N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，代表活节点。</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>B o a r d N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>类型的对象包含如下域： </span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>x</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（电路板的排列），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>s</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（电路板</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x[1:s]) </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>依次放置在位置</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>s </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>上），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c d</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（电路板排列</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x [ 1 : s ]</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的密度，其中包括了到达</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x[s] </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>右边的连线），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n o w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>now[j] </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是排列</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x[1:s] </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中包含</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>j </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的电路板的数目）。当一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>BoardNode </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>类型的对象转换为整型时，其结果即为对象的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>cd </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值。代码见程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 1 0</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:9.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
9.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>17-10 </span><span style='font-size:9.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>电路板排列问题的最小耗费分枝定界算法<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
BBArrangeBoards(int **B, int n, int m, int* &amp;bestx)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>{// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>最小耗费分枝定界算法</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>, m</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>个插槽</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>, n</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>块板<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>MinHeap&lt;BoardNode&gt;
H(1000); // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>容纳活节点<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>初始化第一个</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>节点、</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>t o t a l</span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>b e s t d<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>BoardNode
E;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.x =
new int [n+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.s =
0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>局部排列为</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E . x [ 1 : s ]<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.cd
= 0; // E.x[1:s]</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的密度<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.now
= new int [m+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
*total = new int [m+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>//
now[i] = x[1:s]</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>中含插槽</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>i</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的板的数目<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>//
total[i] = </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>含插槽</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>i</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的板的总数目<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int i = 1; i &lt;= m; i++) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>total[i]
= 0;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.now[i]
= 0;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(i = 1; i &lt;= n; i++) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E.x[i]
= i; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>排列为</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>1 2 3 4 5 . . . n<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 1; j &lt;= m; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>total[j]
+= B[i][j]; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>含插槽</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>j</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>的板<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
bestd = m + 1; / /</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>目前的最优密度<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx
= 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>空指针<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>do
{// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>扩展</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E</span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>节点<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(E.s == n - 1) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>仅有一个孩子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
ld = 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>最后一块板的局部密度<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 1; j &lt;= m; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>ld +=
B[E.x[n]][j];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(ld &lt; bestd) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>更优的排列<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>delete
[] bestx;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestx
= E.x;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>bestd
= max(ld, E.cd);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>else
delete [] E.x;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>delete
[] E.now;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>else
{// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>生成</span><span lang=EN-US style='font-size:8.0pt;
font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>E</span><span lang=EN-US style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>-节点的孩子<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int i = E.s + 1; i &lt;= n; i++) {<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>BoardNode
N;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.now
= new int [m+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 1; j &lt;= m; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>在新板中对插槽计数<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.now[j]
= E.now[j] + B[E.x[i]][j];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>int
ld = 0; // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>新板的局部密度<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(j = 1; j &lt;= m; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(N.now[j] &gt; 0 &amp;&amp; total[j] != N.now[j]) ld++;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.cd
= max(ld, E.cd);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>if
(N.cd &lt; bestd) {// </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>可能会引向更好的叶子<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x =
new int [n+1];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.s =
E.s + 1;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>for
(int j = 1; j &lt;= n; j++)<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x[j]
= E.x[j];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x[N.s]
= E.x[i];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>N.x[i]
= E.x[N.s];<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>H . I
n s e r t ( N ) ; }<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>else
delete [] N.now;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>delete
[] E.x;} // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>处理完当前</span><span lang=EN-US
style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>try
{H.DeleteMin(E);} // </span><span style='font-size:8.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>下一个</span><span lang=EN-US style='font-size:
8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:8.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>catch
(OutOfBounds) {return bestd;} //</span><span style='font-size:8.0pt;font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>没有</span><span lang=EN-US
style='font-size:8.0pt;font-family:Arial;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}
while (E.cd &lt; bestd);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>// </span><span
style='font-size:8.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>释放最小堆中的所有节点<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>do
{delete [] E.x;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>delete
[] E.now;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>try
{H.DeleteMin(E);}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>catch
(...) {break;}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}
while (true);<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>return
bestd;<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:8.0pt;font-family:
Arial;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>}<o:p></o:p></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>程序</span><span lang=EN-US style='font-size:
10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7
- 1 0</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>首先初始化</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span
lang=EN-US style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>-节点为排列树的根，此节点中没有任何电路板，因此有</span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>s=0, cd=0,n o w [ i ] = 0</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>≤</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>≤</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>），</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>是整数</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>到</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的任意排列。接着，程序生成一个整型数组</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>t o t a l</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，其中</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>total[i] </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的值为包含</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的电路板的数目。目前能找到的最优的电路板排列记录在数组</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bestx </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中，对应的密度存储在</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bestd </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中。程序中使用一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>do-while </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>循环来检查每一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点，在每次循环的尾部，将从最小堆中选出具有最小</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>cd </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值的节点作为下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点。如果某个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>cd </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值大于等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bestd</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，则任何剩余的活节点都不能使我们找到密度小于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bestd</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的电路板排列，因此算法终止。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:20.0pt;
mso-char-indent-count:2.0;mso-char-indent-size:10.0pt;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>d o - w h i l e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>循环分两种情况处理</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>-节点，第一种是处理</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>s = n - 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>时的情况，此种情况下，有</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>n - 1</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>个电路板被放置好， </span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点即解空间树中的某个叶节点的父节点。节点对应的密度会被计算出来，如果需要，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bested </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>bestx </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>将被更新。在第二种情况中，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点有两个或更多的孩子。每当一个孩子节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>生成时，它对应的部分排列</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>( x [ 1 : s + 1 ] )</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的密度</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>N . c d</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>就会被计算出来，如果</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>N . c d &lt; b e s t d ,</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>则</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>N</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>被存放在最小优先队列中；如果</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>N . c d</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>≥</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t d</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，则它的子树中的所有叶节点对应的密度都满足</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>d e n s i t y</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>≥</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t d</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，这就意味着不会有优于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的排列。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span style='font-size:12.0pt;font-family:仿宋_GB2312;
color:blue;mso-font-kerning:0pt'>练习<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>3. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>在程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 4</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中增加代码，将指向由函数</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>生成的节点的指针存储在一个链表队列中。</span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>M a x L o a
d i n g</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>必须利用这些指针信息在程序终止之前删除所有生成的节点。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>4. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>本节所使用的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>A d d L i v e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>函数直到程序终止前才删除所生成的节点。实际上，没有活动孩子且不产生叶节点的那些节点都可以被立即删除。类似地，在第</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>n </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>层节点中，若节点没有重量为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的孩子，则可以立即删除该节点。讨论怎样尽快删除不需要的节点。描述实现这种方法时所涉及的时间</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>/</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>空间变化。你推荐使用上述方法吗？<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>5. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>在程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中，定义一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>来记录目前生成的可行节点所对应的重量的最大值。修改程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，使得如果活节点的重量大于等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，则将它加入子集树及最大堆中。此外，还必须增加初始化和更新</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t w</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的代码。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>6. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>只使用一个最大优先队列，来实现用最大收益分枝定界方法求解货箱装船问题，即不要使用程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中所用到的部分解空间树，而在每个优先队列的节点中都加入通向根节点的路径信息。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>7. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>修改程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 6</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，把删除</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b b n o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>类型和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H e a p N o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>类型节点的任务放在程序结尾处。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>8. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>只使用一个最大优先队列，利用最大收益分枝定界法求解</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>0 / 1</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>背包问题，即不必保存一个部分解空间树，所有优先队列中的节点都记录着通往根节点的路径。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>9. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>修改程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 7</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，使得删除</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b b n o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>H e a p N o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>类型的节点的任务放在程序的结尾处执行。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>10. 1) </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>程序</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7 - 8</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>中，若右孩子的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>u n</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>值大于等于</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，则将它加入最大堆中，如果将条件设为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n &gt; b e s t n</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>，程序能否正确执行呢？为什么？<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>程序是否将</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>≥</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的左孩子加入最大堆中？<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>3) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>修改程序，使得只将</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>u n &gt; b e s t n</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的节点加入到最大堆和生成的解空间树中。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>11. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>考察最大完备子图问题的解空间树。对于任意层（第</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>i</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>层）的子树中的节点</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，令</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>MinDegree(x) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x </span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>所包含的顶点的度的最小值。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>1) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>证明任何以</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>x</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>为根的子树的叶节点都不可能表示一个尺寸超过</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>X . u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>＝</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>min{ X.cn+n-i+1,M i n D e g r e e (X)+1 }</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的完备子图。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>2) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用以上</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>X . u n</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的定义重写</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B B M a x C l i q u e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>3) </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>比较两种</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>B B M a x C l i q u e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>版本在运行时间及产生解空间树节点的数目上的不同。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>12. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>只使用最大优先队列，实现最大完备子图问题的最大收益分枝定界算法。即：不必保存一个部分解空间树，而在每一个最大优先队的节点内包含通向根的路径。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>13. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>修改程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 8</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，使得删除</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b b n o d e</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>C l i q u e N o d e</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>类型的节点的工作放在程序结尾处执行。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>14. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>修改程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 9</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，使得</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>s = n - 2</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>的节点不进入优先队列，并且，将当前最优排列放在数组</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>b e s t p</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>中。当下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>lcostbestc </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>时，算法终止。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>15. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用指向父节点的指针来实现部分解空间树，并使用包含</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>l c o s t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>c c</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>，</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>r c o s t</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>和</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>p t r</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>（指向解空间树中对应节点的指针）域的优先队列来实现程序</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7 - 9</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>16. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>写出用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界方法求解电路板排列问题的代码。代码必须输出最优电路板排列的排列次序及对应的密度。使用合适的数据来测试代码的正确性。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>17. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界方法来搜索一种电路板的排列，使得最长的网组的长度最小（参见<span
lang=EN-US>4章练习</span></span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 7</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>）。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>18. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>使用最小耗费分枝定界法来完成练习</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>1 7</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>19. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用最小耗费分枝定界算法求解<span
lang=EN-US>4章练习</span></span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 8</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的顶点覆盖问题。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>20. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用最大收益分枝定界算法求解<span
lang=EN-US>4章练习</span></span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>1 9</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的简易最大切割问题。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>21. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用最小耗费分枝定界算法求解<span
lang=EN-US>4章练习</span></span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>2 0</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的机器设计问题。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>22. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用最小耗费分枝定界算法求解<span
lang=EN-US>4章练习</span></span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>2 1</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的网络设计问题。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>23. </span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>用</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>F I F O</span><span style='font-size:10.0pt;
font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>分枝定界算法求解<span
lang=EN-US>4章练习</span></span><span lang=EN-US style='font-size:10.0pt;
mso-fareast-font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>2 2</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>的</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>n -</span><span style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>皇后放置问题。<span
lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 24. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>分枝定界完成<span lang=EN-US>4章练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 3</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 25. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>分枝定界完成<span lang=EN-US>4章练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 4</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 26. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用</span><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>F I F O</span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>分枝定界完成<span lang=EN-US>4章练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 5</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 27. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用最小耗费分枝定界完成<span lang=EN-US>4章练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 3</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 28. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用最小耗费分枝定界完成<span lang=EN-US>4章练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 4</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 29. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用最小耗费分枝定界完成<span lang=EN-US>4章练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 5</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。<span lang=EN-US><o:p></o:p></span></span></p>

<p class=MsoNormal align=left style='text-align:left;mso-layout-grid-align:
none;text-autospace:none'><span lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:
仿宋_GB2312;color:black;mso-font-kerning:0pt'>* 30. </span><span
style='font-size:10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:
0pt'>用任意的分枝定界方法完成<span lang=EN-US>4章的练习</span></span><span lang=EN-US
style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;color:black;
mso-font-kerning:0pt'>2 5</span><span style='font-size:10.0pt;font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>。在本练习中，必须把增加活节点的函数以及选择下一个</span><span
lang=EN-US style='font-size:10.0pt;mso-fareast-font-family:仿宋_GB2312;
color:black;mso-font-kerning:0pt'>E</span><span lang=EN-US style='font-size:
10.0pt;font-family:仿宋_GB2312;color:black;mso-font-kerning:0pt'>-节点的函数作为函数的参数。<o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:21.0pt;mso-char-indent-count:2.0;
mso-char-indent-size:10.5pt'><span lang=EN-US><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal style='text-indent:21.0pt;mso-char-indent-count:2.0;
mso-char-indent-size:10.5pt'><span style='font-family:宋体;mso-ascii-font-family:
"Times New Roman";mso-hansi-font-family:"Times New Roman"'>（</span> <span
style='font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman"'>说明：本资料是根据《数据结构、算法与应用》（美，</span><span lang=EN-US>Sartaj<span
style="mso-spacerun: yes">&nbsp; </span>Sahni</span><span style='font-family:
宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:"Times New Roman"'>著）一书第</span><span
lang=EN-US>13-17</span><span style='font-family:宋体;mso-ascii-font-family:"Times New Roman";
mso-hansi-font-family:"Times New Roman"'>章编辑、改写的。考虑到因特网传输速度等因素，大部分插图和公式不得不被删除。对于内容不连贯之处，请网友或读者参阅该书，敬请原谅。</span>
<span style='font-family:宋体;mso-ascii-font-family:"Times New Roman";mso-hansi-font-family:
"Times New Roman"'>）</span></p>

<p class=MsoNormal><span lang=EN-US><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

</div>

</body>

</html>
